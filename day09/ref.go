package day09

/*
 * THIS FILE GENERATED BY CHATGPT
 * Using it as a reference for point in polygon implementation
 */

type Pt struct{ X, Y int }
type Seg struct{ A, B Pt }

func RectInsideOrOnPoly(rx1, ry1, rx2, ry2 int, poly []Pt) bool {
	if len(poly) < 3 {
		return false
	}

	xmin, xmax := min(rx1, rx2), max(rx1, rx2)
	ymin, ymax := min(ry1, ry2), max(ry1, ry2)

	// Rectangle corners
	c := [4]Pt{{xmin, ymin}, {xmax, ymin}, {xmax, ymax}, {xmin, ymax}}

	// Rectangle edges
	rEdges := [4]Seg{
		{c[0], c[1]},
		{c[1], c[2]},
		{c[2], c[3]},
		{c[3], c[0]},
	}

	// Polygon edges
	pEdges := make([]Seg, 0, len(poly))
	for i := 0; i < len(poly); i++ {
		j := (i + 1) % len(poly)
		pEdges = append(pEdges, Seg{poly[i], poly[j]})
	}

	// 1) All corners must be inside OR on boundary
	for _, corner := range c {
		if !pointInPolyOrOnEdge(corner, pEdges) {
			return false
		}
	}

	// 2) No proper crossing between rectangle boundary and polygon boundary.
	// Touching at points or colinear overlap is fine.
	for _, re := range rEdges {
		for _, pe := range pEdges {
			if properCrossAxisAligned(re, pe) {
				return false
			}
		}
	}

	return true
}

func pointInPolyOrOnEdge(p Pt, edges []Seg) bool {
	// On boundary => inside (inclusive)
	for _, e := range edges {
		if pointOnSegmentAxisAligned(p, e) {
			return true
		}
	}

	// Ray cast to +X (even/odd). For rectilinear polygon, only vertical edges matter.
	inside := false
	px, py := p.X, p.Y

	for _, e := range edges {
		a, b := e.A, e.B

		// vertical edge
		if a.X == b.X {
			xv := a.X
			y1, y2 := a.Y, b.Y
			if y1 > y2 {
				y1, y2 = y2, y1
			}

			// Half-open [y1, y2) avoids double-counting polygon vertices.
			if py >= y1 && py < y2 {
				if xv > px {
					inside = !inside
				}
			}
		}
	}

	return inside
}

func properCrossAxisAligned(s1, s2 Seg) bool {
	a1, b1 := s1.A, s1.B
	a2, b2 := s2.A, s2.B

	s1H := a1.Y == b1.Y
	s1V := a1.X == b1.X
	s2H := a2.Y == b2.Y
	s2V := a2.X == b2.X

	// Proper crossings only happen when one is horizontal and the other vertical.
	if s1H && s2V {
		return properCrossHV(s1, s2)
	}
	if s1V && s2H {
		return properCrossHV(s2, s1) // swap so first is H
	}

	// Colinear overlaps / touching (H-H or V-V) are NOT “proper crossings” and are allowed.
	return false
}

func properCrossHV(h Seg, v Seg) bool {
	hy := h.A.Y
	hx1, hx2 := h.A.X, h.B.X
	if hx1 > hx2 {
		hx1, hx2 = hx2, hx1
	}

	vx := v.A.X
	vy1, vy2 := v.A.Y, v.B.Y
	if vy1 > vy2 {
		vy1, vy2 = vy2, vy1
	}

	// Do they intersect at all (inclusive)?
	if vx < hx1 || vx > hx2 || hy < vy1 || hy > vy2 {
		return false
	}

	// Proper crossing requires intersection in the *interiors* of BOTH segments,
	// not just touching at an endpoint.
	hInterior := vx > hx1 && vx < hx2
	vInterior := hy > vy1 && hy < vy2

	return hInterior && vInterior
}

func pointOnSegmentAxisAligned(p Pt, s Seg) bool {
	a, b := s.A, s.B

	// vertical
	if a.X == b.X {
		if p.X != a.X {
			return false
		}
		y1, y2 := a.Y, b.Y
		if y1 > y2 {
			y1, y2 = y2, y1
		}
		return p.Y >= y1 && p.Y <= y2
	}

	// horizontal
	if a.Y == b.Y {
		if p.Y != a.Y {
			return false
		}
		x1, x2 := a.X, b.X
		if x1 > x2 {
			x1, x2 = x2, x1
		}
		return p.X >= x1 && p.X <= x2
	}

	// not axis-aligned (unexpected for your input)
	return false
}
